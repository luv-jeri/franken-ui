import JSZip from 'jszip';
import type { DesignTokens, Registry, RegistryItem } from '@franken-ui/core';
import { generateThemeCSS } from './css-generator';
import { buildRegistry, buildStyleItem } from './registry-builder';

interface ExportConfig {
    projectName: string;
    styleName: string;
    tokens: DesignTokens;
    components: Array<{
        name: string;
        code: string;
        dependencies?: string[];
    }>;
}

/**
 * Generate a complete, deployable ZIP export
 */
export async function generateExportZip(config: ExportConfig): Promise<Buffer> {
    const zip = new JSZip();
    const { projectName, styleName, tokens, components } = config;

    // 1. Generate theme CSS
    const themeCSS = generateThemeCSS(tokens);
    zip.file('styles/theme.css', themeCSS);

    // 2. Build registry items
    const registryItems: RegistryItem[] = [
        buildStyleItem(styleName, tokens),
    ];

    for (const component of components) {
        registryItems.push({
            name: component.name,
            type: 'registry:ui',
            dependencies: component.dependencies || [],
            files: [
                {
                    path: `registry/${styleName}/${component.name}/${component.name}.tsx`,
                    type: 'registry:ui',
                    content: component.code,
                },
            ],
        });

        // Add component source file
        zip.file(
            `registry/${styleName}/${component.name}/${component.name}.tsx`,
            component.code
        );

        // Add component JSON for public/r/
        zip.file(
            `public/r/${component.name}.json`,
            JSON.stringify(registryItems[registryItems.length - 1], null, 2)
        );
    }

    // 3. Generate registry.json
    const registry: Registry = buildRegistry(projectName, '', registryItems);
    zip.file('registry.json', JSON.stringify(registry, null, 2));
    zip.file('public/r/registry.json', JSON.stringify(registry, null, 2));

    // 4. Add package.json
    zip.file('package.json', JSON.stringify({
        name: projectName,
        version: '0.0.1',
        private: true,
        scripts: {
            dev: 'next dev',
            build: 'next build',
            start: 'next start',
            'registry:build': 'shadcn build',
        },
        dependencies: {
            next: '^15.0.0',
            react: '^19.0.0',
            'react-dom': '^19.0.0',
            'framer-motion': '^11.0.0',
            'class-variance-authority': '^0.7.0',
            clsx: '^2.1.0',
            'tailwind-merge': '^2.2.0',
        },
        devDependencies: {
            typescript: '^5.0.0',
            tailwindcss: '^4.0.0',
            shadcn: '^latest',
        },
    }, null, 2));

    // 5. Add globals.css
    zip.file('app/globals.css', `@import "tailwindcss";
@import "../styles/theme.css";

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family: var(--font-body);
  }
  h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-heading);
  }
}
`);

    // 6. Add README.md
    zip.file('README.md', `# ${projectName}

A custom shadcn/ui registry generated by Franken-UI.

## Quick Start

\`\`\`bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Your registry is available at:
# http://localhost:3000/r/registry.json
\`\`\`

## Using This Registry

In any project with shadcn installed:

\`\`\`bash
npx shadcn add http://localhost:3000/r/button.json
\`\`\`

## Deploying

Deploy to Vercel:

\`\`\`bash
npx vercel
\`\`\`

Then use: \`https://your-project.vercel.app/r/button.json\`
`);

    // 7. Add components.json
    zip.file('components.json', JSON.stringify({
        $schema: 'https://ui.shadcn.com/schema.json',
        style: styleName,
        tailwind: {
            config: '',
            css: 'app/globals.css',
            baseColor: 'neutral',
            cssVariables: true,
        },
        aliases: {
            components: '@/components',
            utils: '@/lib/utils',
            ui: '@/components/ui',
            lib: '@/lib',
            hooks: '@/hooks',
        },
    }, null, 2));

    return zip.generateAsync({ type: 'nodebuffer' }) as Promise<Buffer>;
}
